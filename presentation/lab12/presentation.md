---
lang: ru-RU
title: "Презентация по лабораторной работе №12"
subtitle: "Архитектура компьютеров и операционные системы"
author:
  - "Цезарь Кайзер"
institute:
  - "Российский университет дружбы народов, Москва, Россия"
date: "29 августа 2025"
---

# Цель работы

Изучение принципов программирования в командном процессоре Unix, создание скриптов для автоматизации задач и обработки данных.

# Задание

1. Создание скрипта для резервного копирования
2. Создание командного файла для обработки аргументов
3. Создание аналога команды `ls`
4. Создание скрипта для подсчета файлов по форматам

# Скрипт для резервного копирования

## Код скрипта backup.sh

```bash
#!/bin/bash

# Скрипт для резервного копирования файлов

# Проверка наличия аргументов
if [ $# -lt 2 ]; then
    echo "Использование: $0 <исходный_каталог> <каталог_назначения>"
    exit 1
fi

# Получение аргументов
SOURCE_DIR=$1
DEST_DIR=$2
BACKUP_DATE=$(date +%Y%m%d_%H%M%S)
ARCHIVE_NAME="backup_${BACKUP_DATE}.tar.gz"

# Проверка существования исходного каталога
if [ ! -d "$SOURCE_DIR" ]; then
    echo "Ошибка: Исходный каталог '$SOURCE_DIR' не существует."
    exit 1
fi

# Создание каталога назначения, если он не существует
if [ ! -d "$DEST_DIR" ]; then
    mkdir -p "$DEST_DIR"
    if [ $? -ne 0 ]; then
        echo "Ошибка: Не удалось создать каталог назначения '$DEST_DIR'."
        exit 1
    fi
    echo "Создан каталог назначения: $DEST_DIR"
fi

# Создание архива
echo "Создание резервной копии из '$SOURCE_DIR' в '$DEST_DIR/$ARCHIVE_NAME'..."
tar -czf "$DEST_DIR/$ARCHIVE_NAME" -C "$SOURCE_DIR" .

# Проверка успешности создания архива
if [ $? -eq 0 ]; then
    echo "Резервное копирование успешно завершено."
    echo "Архив сохранен как: $DEST_DIR/$ARCHIVE_NAME"
    echo "Размер архива: $(du -h "$DEST_DIR/$ARCHIVE_NAME" | cut -f1)"
else
    echo "Ошибка: Не удалось создать архив."
    exit 1
fi

exit 0
```

# Командный файл для обработки аргументов

## Код скрипта args.sh

```bash
#!/bin/bash

# Скрипт для обработки аргументов командной строки

echo "Общее количество аргументов: $#"
echo "Имя скрипта: $0"

# Вывод всех аргументов
echo "Все аргументы: $@"

# Вывод аргументов по отдельности
echo "Аргументы по отдельности:"
count=1
for arg in "$@"; do
    echo "Аргумент $count: $arg"
    count=$((count + 1))
done

# Вывод аргументов в обратном порядке
echo "Аргументы в обратном порядке:"
for (( i=$#; i>0; i-- )); do
    echo "Аргумент $i: ${!i}"
done

exit 0
```

# Аналог команды `ls`

## Код скрипта myls.sh

```bash
#!/bin/bash

# Скрипт-аналог команды ls

# Функция для вывода справки
show_help() {
    echo "Использование: $0 [опции] [каталог]"
    echo "Опции:"
    echo "  -a    Показать все файлы, включая скрытые"
    echo "  -l    Подробный формат вывода"
    echo "  -h    Показать эту справку"
    exit 0
}

# Инициализация переменных
show_hidden=0
long_format=0
directory="."

# Обработка опций
while getopts "alh" opt; do
    case $opt in
        a) show_hidden=1 ;;
        l) long_format=1 ;;
        h) show_help ;;
        \?) echo "Неизвестная опция: -$OPTARG" >&2; exit 1 ;;
    esac
done

# Сдвиг обработанных опций
shift $((OPTIND - 1))

# Если указан каталог, используем его
if [ $# -gt 0 ]; then
    directory="$1"
fi

# Проверка существования каталога
if [ ! -d "$directory" ]; then
    echo "Ошибка: Каталог '$directory' не существует."
    exit 1
fi

# Получение списка файлов
if [ $show_hidden -eq 1 ]; then
    files=($(ls -a "$directory"))
else
    files=($(ls "$directory"))
fi

# Вывод результатов
echo "Содержимое каталога: $directory"
echo "------------------------"

for file in "${files[@]}"; do
    # Пропускаем . и .. если не показываем скрытые файлы
    if [ $show_hidden -eq 0 ] && [[ "$file" == "." || "$file" == ".." ]]; then
        continue
    fi
    
    full_path="$directory/$file"
    
    if [ $long_format -eq 1 ]; then
        # Тип файла
        if [ -d "$full_path" ]; then
            type="d"
        elif [ -L "$full_path" ]; then
            type="l"
        else
            type="-"
        fi
        
        # Права доступа
        permissions=""
        if [ -r "$full_path" ]; then permissions="${permissions}r"; else permissions="${permissions}-"; fi
        if [ -w "$full_path" ]; then permissions="${permissions}w"; else permissions="${permissions}-"; fi
        if [ -x "$full_path" ]; then permissions="${permissions}x"; else permissions="${permissions}-"; fi
        
        # Размер и дата модификации
        size=$(du -h "$full_path" 2>/dev/null | cut -f1)
        mod_date=$(date -r "$full_path" "+%Y-%m-%d %H:%M")
        
        echo "$type$permissions $size $mod_date $file"
    else
        echo "$file"
    fi
done

exit 0
```

# Подсчет файлов по форматам

## Код скрипта countfiles.sh

```bash
#!/bin/bash

# Скрипт для подсчета файлов по форматам

# Проверка наличия аргумента
if [ $# -lt 1 ]; then
    echo "Использование: $0 <каталог>"
    exit 1
fi

# Получение аргумента
directory="$1"

# Проверка существования каталога
if [ ! -d "$directory" ]; then
    echo "Ошибка: Каталог '$directory' не существует."
    exit 1
fi

echo "Подсчет файлов по форматам в каталоге: $directory"
echo "------------------------------------------------"

# Получение списка всех файлов рекурсивно
files=$(find "$directory" -type f | sort)

# Инициализация ассоциативного массива для подсчета
declare -A formats_count

# Подсчет файлов по расширениям
for file in $files; do
    # Получение расширения файла
    extension="${file##*.}"
    
    # Если файл не имеет расширения, считаем его как "без расширения"
    if [ "$extension" = "$file" ]; then
        extension="без расширения"
    else
        extension=".$extension"
    fi
    
    # Увеличиваем счетчик для данного расширения
    if [ -z "${formats_count[$extension]}" ]; then
        formats_count[$extension]=1
    else
        formats_count[$extension]=$((formats_count[$extension] + 1))
    fi
done

# Вывод результатов
echo "Формат | Количество файлов"
echo "------------------------"
for format in "${!formats_count[@]}"; do
    count=${formats_count[$format]}
    
    # Правильное склонение слова "файл"
    if [ $count -eq 1 ]; then
        word="файл"
    elif [ $count -ge 2 ] && [ $count -le 4 ]; then
        word="файла"
    else
        word="файлов"
    fi
    
    echo "$format: ${formats_count[$format]} $word"
done

# Общее количество файлов
total=0
for count in "${formats_count[@]}"; do
    total=$((total + count))
done

echo "------------------------"
echo "Всего: $total файлов"

exit 0
```

# Выводы

1. Я освоил основы создания скриптов на Bash, включая работу с переменными, условными операторами и циклами.
2. Научился работать с аргументами командной строки и обрабатывать их в скриптах.
3. Изучил механизм архивации файлов в Unix с помощью команды tar.
4. Освоил работу с файловой системой: проверку существования файлов и каталогов, получение информации о файлах.
5. Научился использовать ассоциативные массивы для подсчета и группировки данных.
6. Понял принципы создания пользовательских аналогов стандартных команд Unix.

# Контрольные вопросы

## 1. Что такое командная оболочка?

Командная оболочка (shell) - это программа, которая предоставляет интерфейс между пользователем и операционной системой. Она интерпретирует команды пользователя и передает их ядру ОС для выполнения.

## 2. Что такое POSIX?

POSIX (Portable Operating System Interface) - это набор стандартов, определяющих интерфейс между операционной системой и прикладными программами, обеспечивающий совместимость между различными UNIX-подобными операционными системами.

## 3. Основные возможности командных оболочек

- Выполнение команд и программ
- Перенаправление ввода/вывода
- Конвейерная обработка данных (pipes)
- Управление заданиями (jobs)
- Подстановка имен файлов (wildcards)
- Программирование с использованием переменных, условий, циклов

## 4. Переменные окружения

Переменная окружения - это динамическая переменная в операционной системе, которая содержит информацию, используемую одной или несколькими программами. Например, PATH определяет каталоги для поиска исполняемых файлов.

## 5. Команды set и unset

- `set` используется для установки или отображения переменных оболочки
- `unset` используется для удаления переменных или функций из окружения оболочки

## 6. Определение функций в bash

```bash
function_name() {
    # команды
    return value  # необязательно
}
```

## 7. Команды let и read

- `let` выполняет арифметические операции над переменными
- `read` считывает строку из стандартного ввода и присваивает ее переменным

## 8. Позиционные параметры

Позиционные параметры - это специальные переменные в скриптах, которые содержат аргументы командной строки. $0 содержит имя скрипта, $1 - первый аргумент, $2 - второй и т.д.

## 9. Возврат значений из функций

Функции в bash возвращают значения через:
- Код возврата (0-25) с помощью команды `return`
- Вывод результата в stdout с помощью `echo` или `printf`
- Изменение глобальных переменных внутри функции

## 10. Локальные переменные

Локальные переменные - это переменные, объявленные с ключевым словом `local` внутри функции. Они видны только внутри функции.

## 11. Рекурсия в bash

Рекурсия - это процесс, при котором функция вызывает сама себя:
```bash
factorial() {
    if [ $1 -le 1 ]; then
        echo 1
    else
        local temp=$(factorial $(( $1 - 1 )))
        echo $(( $1 * temp ))
    fi
}
```

## 12. Командная подстановка

Командная подстановка - это механизм, позволяющий использовать вывод одной команды как аргумент для другой команды или для присваивания переменной: \`command\` или $(command).

## 13. Массивы в bash

```bash
# Создание массива
array=("element1" "element2" "element3")

# Доступ к элементам
echo ${array[0]}  # первый элемент
echo ${array[@]}  # все элементы
```

## 14. Регулярные выражения

Регулярные выражения - это шаблоны, используемые для поиска и обработки текста. В Unix регулярные выражения используются во многих утилитах, таких как grep, sed, awk.

## 15. Обработка ошибок в bash

Обработка ошибок в bash осуществляется через:
- Проверка кода возврата команд с помощью `$?`
- Использование условных операторов
- Использование конструкции `set -e` для автоматического завершения скрипта при ошибке
- Использование конструкции `trap` для перехвата сигналов
